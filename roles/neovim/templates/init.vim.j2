{# TODO: switch to lua based config #}
{{ ansible_managed | comment(decoration='" ') }}
let mapleader = ","
let g:mapleader = ","

" ********** PLUGINS **********
if &compatible
    set nocompatible
endif

" Required:
call plug#begin('{{ neovim_plugins_dir }}')

Plug 'junegunn/vim-plug'

Plug 'kyazdani42/nvim-web-devicons'

Plug 'kyazdani42/nvim-tree.lua'
let g:nvim_tree_icons = {
    \ 'default': '',
    \ 'symlink': '',
    \ 'git': {
    \   'unstaged': "✗",
    \   'staged': "✓",
    \   'unmerged': "",
    \   'renamed': "➜",
    \   'untracked': "★",
    \   'deleted': "",
    \   'ignored': "◌"
    \   },
    \ 'folder': {
    \   'arrow_open': "",
    \   'arrow_closed': "",
    \   'default': "",
    \   'open': "",
    \   'empty': "",
    \   'empty_open': "",
    \   'symlink': "",
    \   'symlink_open': "",
    \   },
    \   'lsp': {
    \     'hint': "",
    \     'info': "",
    \     'warning': "",
    \     'error': "",
    \   }
    \ }
let g:nvim_tree_gitignore = 1
let g:nvim_tree_follow = 1
let g:nvim_tree_hide_dotfiles = 1
let g:nvim_tree_lsp_diagnostics = 1
let g:nvim_tree_auto_open = 1
nnoremap <leader>t :NvimTreeToggle<CR>
nnoremap <C-r> :NvimTreeRefresh<CR>

Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}

Plug 'easymotion/vim-easymotion'

Plug 'blueyed/vim-diminactive'
let g:diminactive_enable_focus = 1

Plug 'lewis6991/gitsigns.nvim'

Plug 'tpope/vim-fugitive'

Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
nnoremap <C-p> <cmd>Telescope find_files<cr>
nnoremap <C-b> <cmd>Telescope buffers<cr>
nnoremap <C-f> <cmd>Telescope live_grep<cr>
" nnoremap <leader>fh <cmd>Telescope help_tags<cr>

Plug 'folke/todo-comments.nvim'
nnoremap <silent> <F10> :TodoTelescope<CR>

Plug 'editorconfig/editorconfig-vim'

Plug 'pearofducks/ansible-vim'

Plug 'jvirtanen/vim-hcl'

Plug 'hashivim/vim-terraform'
let g:terraform_fmt_on_save=1

Plug 'towolf/vim-helm'

Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }, 'for': ['markdown', 'vim-plug']}

Plug 'lukas-reineke/indent-blankline.nvim'
let g:indent_blankline_show_first_indent_level = v:false

" LSP
Plug 'kabouzeid/nvim-lspinstall'
Plug 'neovim/nvim-lspconfig'

Plug 'ray-x/lsp_signature.nvim'

Plug 'onsails/lspkind-nvim'

" autocompletion
Plug 'hrsh7th/nvim-cmp'
Plug 'hrsh7th/cmp-nvim-lsp'

" ui
Plug 'glepnir/galaxyline.nvim'

" colors
Plug 'rktjmp/lush.nvim'
Plug 'arcticicestudio/nord-vim'

" enable true colors
if exists('+termguicolors')
  let &t_8f="\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b="\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
endif

" Required:
call plug#end()
lua << EOF
require('gitsigns').setup {
  current_line_blame = true,
}

require("todo-comments").setup {
  signs = false,
}

require("indent_blankline").setup {
    space_char_blankline = " ",
    show_current_context = true,
}

require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    "bash",
    "comment",
    "dockerfile",
    "hcl",
    "python",
    "rust",
    "toml",
    "yaml",
  },
  highlight = {
    enable = true,              -- false will disable the whole extension
    additional_vim_regex_highlighting = false,
  },
}

require('telescope').setup{
  defaults = {
    vimgrep_arguments = {
      'rg',
      '--color=never',
      '--no-heading',
      '--with-filename',
      '--line-number',
      '--column',
      '--smart-case'
    },
    prompt_prefix = "> ",
    selection_caret = "> ",
    entry_prefix = "  ",
    initial_mode = "insert",
    selection_strategy = "reset",
    sorting_strategy = "descending",
    layout_strategy = "horizontal",
    layout_config = {
      horizontal = {
        mirror = false,
      },
      vertical = {
        mirror = false,
      },
    },
    file_sorter =  require'telescope.sorters'.get_fuzzy_file,
    file_ignore_patterns = {},
    generic_sorter =  require'telescope.sorters'.get_generic_fuzzy_sorter,
    winblend = 0,
    border = {},
    borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰' },
    color_devicons = true,
    use_less = true,
    path_display = {},
    set_env = { ['COLORTERM'] = 'truecolor' }, -- default = nil,
    file_previewer = require'telescope.previewers'.vim_buffer_cat.new,
    grep_previewer = require'telescope.previewers'.vim_buffer_vimgrep.new,
    qflist_previewer = require'telescope.previewers'.vim_buffer_qflist.new,
    -- Developer configurations: Not meant for general override
    buffer_previewer_maker = require'telescope.previewers'.buffer_previewer_maker
  }
}

local function on_attach(_, bufnr)
  local function buf_set_keymap(...)
    vim.api.nvim_buf_set_keymap(bufnr, ...)
  end
  local function buf_set_option(...)
    vim.api.nvim_buf_set_option(bufnr, ...)
  end
  -- Enable completion triggered by <c-x><c-o>
  -- TODO: switch to https://github.com/hrsh7th/nvim-cmp or something
  -- buf_set_option("omnifunc", "v:lua.vim.lsp.omnifunc")
  -- Mappings.
  local opts = { noremap = true, silent = true }
  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap("n", "gd", "<cmd>lua vim.lsp.buf.definition()<CR>", opts)
  buf_set_keymap("n", "gi", "<cmd>lua vim.lsp.buf.implementation()<CR>", opts)
  buf_set_keymap("n", "gr", "<cmd>lua vim.lsp.buf.references()<CR>", opts)
  buf_set_keymap("n", "gD", "<cmd>lua vim.lsp.buf.type_definition()<CR>", opts)
  buf_set_keymap("n", "K", "<cmd>lua vim.lsp.buf.hover()<CR>", opts)
  buf_set_keymap("n", "<C-k>", "<cmd>lua vim.lsp.buf.signature_help()<CR>", opts)
  buf_set_keymap("n", "<F2>", "<cmd>lua vim.lsp.buf.rename()<CR>", opts)
  buf_set_keymap("n", "<C-space>", "<cmd>lua vim.lsp.buf.code_action()<CR>", opts)
  buf_set_keymap("v", "<C-space>", "<cmd>lua vim.lsp.buf.range_code_action()<CR>", opts)
  buf_set_keymap("n", "[", "<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>", opts)
  buf_set_keymap("n", "]", "<cmd>lua vim.lsp.diagnostic.goto_next()<CR>", opts)
  buf_set_keymap("n", "<space>e", "<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>", opts)
  buf_set_keymap("n", "<space>q", "<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>", opts)
  buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
end

local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.documentationFormat = { "markdown", "plaintext" }
capabilities.textDocument.completion.completionItem.snippetSupport = true
capabilities.textDocument.completion.completionItem.preselectSupport = true
capabilities.textDocument.completion.completionItem.insertReplaceSupport = true
capabilities.textDocument.completion.completionItem.labelDetailsSupport = true
capabilities.textDocument.completion.completionItem.deprecatedSupport = true
capabilities.textDocument.completion.completionItem.commitCharactersSupport = true
capabilities.textDocument.completion.completionItem.tagSupport = { valueSet = { 1 } }
capabilities.textDocument.completion.completionItem.resolveSupport = {
  properties = {
    "documentation",
    "detail",
    "additionalTextEdits",
  },
}

local function setup_servers()
  require'lspinstall'.setup()
  local servers = require'lspinstall'.installed_servers()
  for _, server in pairs(servers) do
    require'lspconfig'[server].setup{
      on_attach = on_attach,
      capabilities = capabilities,
      flags = {
        debounce_text_changes = 300,
      },
    }
  end
end
setup_servers()

-- Automatically reload after `:LspInstall <server>` so we don't have to restart neovim
require'lspinstall'.post_install_hook = function ()
  setup_servers() -- reload installed servers
  vim.cmd("bufdo e") -- this triggers the FileType autocmd that starts the server
end

require "lsp_signature".setup({
  bind = true,
  doc_lines = 2,
  floating_window = true,
  fix_pos = true,
  hint_enable = true,
  hint_prefix = " ",
  hint_scheme = "String",
  use_lspsaga = false,
  hi_parameter = "Search",
  max_height = 22,
  max_width = 120, -- max_width of signature floating_window, line will be wrapped if exceed max_width
  handler_opts = {
    border = "single", -- double, single, shadow, none
  },
  zindex = 200, -- by default it will be on top of all floating windows, set to 50 send it to bottom
  padding = "", -- character to pad on left and right of signature can be ' ', or '|'  etc
})

-- Autocompletion
-- https://github.com/neovim/nvim-lspconfig/wiki/Autocompletion
vim.o.completeopt = 'menuone,noselect'
local lspkind = require('lspkind')
local cmp = require 'cmp'
cmp.setup {
  formatting = {
    format = function(entry, vim_item)
      vim_item.kind = lspkind.presets.default[vim_item.kind]
      return vim_item
    end
  },
  mapping = {
    ['<C-p>'] = cmp.mapping.select_prev_item(),
    ['<C-n>'] = cmp.mapping.select_next_item(),
    ['<C-d>'] = cmp.mapping.scroll_docs(-4),
    ['<C-f>'] = cmp.mapping.scroll_docs(4),
    ['<C-Space>'] = cmp.mapping.complete(),
    ['<C-e>'] = cmp.mapping.close(),
    ['<CR>'] = cmp.mapping.confirm {
      behavior = cmp.ConfirmBehavior.Replace,
      select = true,
    },
    ['<Tab>'] = function(fallback)
      if vim.fn.pumvisible() == 1 then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-n>', true, true, true), 'n')
      else
        fallback()
      end
    end,
    ['<S-Tab>'] = function(fallback)
      if vim.fn.pumvisible() == 1 then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-p>', true, true, true), 'n')
      else
        fallback()
      end
    end,
  },
  sources = {
    { name = 'nvim_lsp' },
  },
}

local vim = vim
local gl = require('galaxyline')
local vcs = require('galaxyline.provider_vcs')

local gls = gl.section
gl.short_line_list = {
  'startify', 'undotree', 'fugitive', 'fugitiveblame', 'startuptime',
  'NvimTree', 'vista', 'dbui', 'packer'
}

local hsl = require('lush').hsl
-- Colors
local clrs = {
  nord0 = hsl(220, 16, 22),
  nord1 = hsl(222, 16, 28),
  nord2 = hsl(220, 17, 32),
  nord3 = hsl(220, 16, 36),
  nord3_bright = hsl(220, 17, 46),
  nord4 = hsl(219, 28, 88),
  nord5 = hsl(218, 27, 92),
  nord6 = hsl(218, 27, 94),
  nord7 = hsl(179, 25, 65),
  nord8 = hsl(193, 43, 67),
  nord9 = hsl(210, 34, 63),
  nord10 = hsl(213, 32, 52),
  nord11 = hsl(354, 42, 56),
  nord12 = hsl(14, 51, 63),
  nord13 = hsl(40, 71, 73),
  nord14 = hsl(92, 28, 65),
  nord15 = hsl(311, 20, 63)
}

local colors = {
  bg = clrs.nord0.hex,
  section_bg = clrs.nord1.hex,
  blue = clrs.nord9.hex,
  cyan = clrs.nord8.hex,
  darkblue = clrs.nord10.hex,
  fg = clrs.nord4.hex,
  green = clrs.nord14.hex,
  magenta = clrs.nord15.hex,
  orange = clrs.nord12.hex,
  red = clrs.nord11.hex,
  violet = clrs.nord15.da(10).hex,
  yellow = clrs.nord13.hex
}


-- Local helper functions
local is_buffer_empty = function()
  return vim.fn.empty(vim.fn.expand('%:t')) == 1
end

local buffer_not_empty = function()
  return not is_buffer_empty()
end

local in_git_repo = function ()
  local vcs = require('galaxyline.provider_vcs')
  local branch_name = vcs.get_git_branch()

  return branch_name ~= nil
end

local mode_color = function()
  local mode_colors = {
    n = colors.cyan,
    i = colors.green,
    c = colors.orange,
    V = colors.magenta,
    [''] = colors.magenta,
    v = colors.magenta,
    R = colors.red,
  }

  local color = mode_colors[vim.fn.mode()]

  if color == nil then
    color = colors.red
  end

  return color
end

-- Left side
gls.left[1] = {
  FirstElement = {
    provider = function() return '▋ ' end,
    highlight = { colors.cyan, colors.bg }
  },
}
gls.left[2] = {
  ViMode = {
    provider = function()
      local alias = {
        n = 'N',
        i = 'I',
        c = 'C',
        V = 'V',
        [''] = 'V',
        v = 'V',
        R = 'R',
      }
      vim.api.nvim_command('hi GalaxyViMode guifg='..mode_color())
      local alias_mode = alias[vim.fn.mode()]
      if alias_mode == nil then
        alias_mode = vim.fn.mode()
      end
      return alias_mode..' '
    end,
    highlight = { colors.bg, colors.bg },
    separator = "  ",
    separator_highlight = { colors.bg, colors.section_bg },
  },
}
gls.left[3] ={
  FileIcon = {
    provider = 'FileIcon',
    condition = buffer_not_empty,
    highlight = { require('galaxyline.provider_fileinfo').get_file_icon_color, colors.section_bg },
  },
}
gls.left[4] = {
  FileName = {
    provider = 'FileName',
    condition = buffer_not_empty,
    highlight = { colors.fg, colors.section_bg },
    separator = " ",
    separator_highlight = { colors.section_bg, colors.bg },
  }
}
-- gls.left[5] = {
--   GitIcon = {
--     provider = function() return '  ' end,
--     condition = in_git_repo,
--     highlight = {colors.red,colors.bg},
--   }
-- }
-- gls.left[6] = {
--   GitBranch = {
--     provider = function()
--       local vcs = require('galaxyline.provider_vcs')
--       local branch_name = vcs.get_git_branch()
--       if (string.len(branch_name) > 28) then
--         return string.sub(branch_name, 1, 25).."..."
--       end
--       return branch_name .. " "
--     end,
--     condition = in_git_repo,
--     highlight = {colors.fg,colors.bg},
--   }
-- }
gls.left[7] = {
  DiffAdd = {
    provider = vcs.diff_add,
    condition = in_git_repo,
    icon = ' ',
    highlight = { colors.green, colors.bg },
  }
}
gls.left[8] = {
  DiffModified = {
    provider = vcs.diff_modified,
    condition = in_git_repo,
    icon = ' ',
    highlight = { colors.orange, colors.bg },
  }
}
gls.left[9] = {
  DiffRemove = {
    provider = vcs.diff_remove,
    condition = in_git_repo,
    icon = ' ',
    highlight = { colors.red, colors.bg },
  }
}
gls.left[10] = {
  LeftEnd = {
    condition = buffer_not_empty,
    provider = function() return '' end,
    highlight = { colors.section_bg, colors.bg },
    separator = ' ',
    separator_highlight = { colors.section_bg, colors.section_bg },
  }
}
gls.left[11] = {
  DiagnosticError = {
    provider = 'DiagnosticError',
    icon = '  ',
    highlight = {colors.red,colors.section_bg}
  }
}
gls.left[12] = {
  Space = {
    provider = function () return ' ' end,
    highlight = {colors.section_bg,colors.section_bg},
  }
}
gls.left[13] = {
  DiagnosticWarn = {
    provider = 'DiagnosticWarn',
    icon = '  ',
    highlight = {colors.orange,colors.section_bg},
  }
}
gls.left[14] = {
  Space = {
    provider = function () return ' ' end,
    highlight = {colors.section_bg,colors.section_bg},
  }
}
gls.left[15] = {
  DiagnosticInfo = {
    provider = 'DiagnosticInfo',
    icon = '  ',
    highlight = {colors.blue,colors.section_bg},
    separator = ' ',
    separator_highlight = { colors.section_bg, colors.bg },
  }
}

-- Right side
gls.right[1] = {
  LspClient = {
    provider = 'GetLspClient',
    icon = ' ',
    highlight = { colors.blue, colors.bg },
  }
}
gls.right[2] = {
  Separator = {
    provider = function () return '  ' end,
    highlight = { colors.section_bg, colors.bg },
  }
}
gls.right[3] = {
  Space = {
    provider = function () return ' ' end,
    highlight = { colors.section_bg, colors.bg },
  }
}
gls.right[4]= {
  FileFormat = {
    provider = function() return vim.bo.filetype end,
    highlight = { colors.fg, colors.section_bg },
  }
}
gls.right[5] = {
  LineInfo = {
    provider = 'LineColumn',
    highlight = { colors.fg, colors.section_bg },
    separator = ' | ',
    separator_highlight = { colors.bg, colors.section_bg },
  },
}

-- Short status line
gls.short_line_left[1] = {
  BufferType = {
    provider = 'FileTypeName',
    highlight = { colors.fg, colors.section_bg },
    separator = ' ',
    separator_highlight = { colors.section_bg, colors.bg },
  }
}

gls.short_line_right[1] = {
  BufferIcon = {
    provider= 'BufferIcon',
    highlight = { colors.yellow, colors.section_bg },
    separator = ' ',
    separator_highlight = { colors.section_bg, colors.bg },
  }
}

-- Force manual load so that nvim boots with a status line
gl.load_galaxyline()
EOF

" -----------------------------------------------------------------------------
filetype plugin indent on

" ********** SETTINGS **********
set encoding=utf8
set listchars=tab:▷⋅,trail:⋅
set list
set t_Co=256
set history=100
set autoread
set nonumber
set scrolloff=10
set wildmenu
set wildignore=*.o,*~,*.pyc,.git\*,.hg\*,.svn\*
set cmdheight=1
set hidden
set ignorecase smartcase hlsearch incsearch magic showmatch
set lazyredraw
set mat=2
set noerrorbells novisualbell t_vb= tm=500
set foldcolumn=0
syntax enable
set background=dark
colorscheme nord
set ffs=unix,dos,mac
set nobackup nowb noswapfile backupcopy=yes
set shiftwidth=4 tabstop=4 expandtab
set lbr tw=500
set ruler cursorline colorcolumn=80
set autoindent
set viminfo^=%
set laststatus=2
set noshowmode
set conceallevel=0
set mouse-=a
set nowrap
set autowriteall

" ********** FUNCTIONS **********
" Delete trailing white space on save, useful for Python and CoffeeScript ;)
func! DeleteTrailingWS()
    exe "normal mz"
    %s/\s\+$//ge
    exe "normal `z"
endfunc

" Delete buffer while keeping window layout (don't close buffer's windows).
" Version 2008-11-18 from http://vim.wikia.com/wiki/VimTip165
if v:version < 700 || exists('loaded_bclose') || &cp
    finish
endif
let loaded_bclose = 1
if !exists('bclose_multiple')
    let bclose_multiple = 1
endif

" Display an error message.
function! s:Warn(msg)
    echohl ErrorMsg
    echomsg a:msg
    echohl NONE
endfunction

" Command ':Bclose' executes ':bd' to delete buffer in current window.
" The window will show the alternate buffer (Ctrl-^) if it exists,
" or the previous buffer (:bp), or a blank buffer if no previous.
" Command ':Bclose!' is the same, but executes ':bd!' (discard changes).
" An optional argument can specify which buffer to close (name or number).
function! s:Bclose(bang, buffer)
    if empty(a:buffer)
        let btarget = bufnr('%')
    elseif a:buffer =~ '^\d\+$'
        let btarget = bufnr(str2nr(a:buffer))
    else
        let btarget = bufnr(a:buffer)
    endif
    if btarget < 0
        call s:Warn('No matching buffer for '.a:buffer)
        return
    endif
    if empty(a:bang) && getbufvar(btarget, '&modified')
        call s:Warn('No write since last change for buffer '.btarget.' (use :Bclose!)')
        return
    endif
    " Numbers of windows that view target buffer which we will delete.
    let wnums = filter(range(1, winnr('$')), 'winbufnr(v:val) == btarget')
    if !g:bclose_multiple && len(wnums) > 1
        call s:Warn('Buffer is in multiple windows (use ":let bclose_multiple=1")')
        return
    endif
    let wcurrent = winnr()
    for w in wnums
        execute w.'wincmd w'
        let prevbuf = bufnr('#')
        if prevbuf > 0 && buflisted(prevbuf) && prevbuf != w
            buffer #
        else
            bprevious
        endif
        if btarget == bufnr('%')
            " Numbers of listed buffers which are not the target to be deleted.
            let blisted = filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != btarget')
            " Listed, not target, and not displayed.
            let bhidden = filter(copy(blisted), 'bufwinnr(v:val) < 0')
            " Take the first buffer, if any (could be more intelligent).
            let bjump = (bhidden + blisted + [-1])[0]
            if bjump > 0
                execute 'buffer '.bjump
            else
                execute 'enew'.a:bang
            endif
        endif
    endfor
    execute 'bdelete'.a:bang.' '.btarget
    execute wcurrent.'wincmd w'
endfunction
command! -bang -complete=buffer -nargs=? Bclose call s:Bclose('<bang>', '<args>')

function! MaximizeToggle()
    if exists("s:maximize_session")
        exec "source " . s:maximize_session
        call delete(s:maximize_session)
        unlet s:maximize_session
        let &hidden=s:maximize_hidden_save
        unlet s:maximize_hidden_save
    else
        let s:maximize_hidden_save = &hidden
        let s:maximize_session = tempname()
        set hidden
        exec "mksession! " . s:maximize_session
        only
    endif
endfunction

" ********** MAPPINGS **********
nnoremap <silent> <leader>q :Bclose<CR>
nnoremap <leader>w :wa!<cr>
nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>
map 0 ^
nnoremap <C-w>z :call MaximizeToggle()<CR>

" ********** HOOKS **********
" Return to last edit position when opening files (You want this!)
autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif
autocmd FocusLost * :wa
autocmd BufWrite * :call DeleteTrailingWS()
au InsertLeave * set nopaste
